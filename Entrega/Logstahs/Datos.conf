input {
  # Lectura del archivo .ndjson
  file {
    path => "/home/g6/reto/datos/steam-games-data-vect.ndjson"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
  }
}

filter {
  # --- 1. Procesamiento de fechas ---
  if [release_date] {
    date {
      match => [ "release_date", "yyyy-MM-dd" ]
      target => "release_date"
      timezone => "UTC"
    }
  }

  # --- 2. Grok para extraer requisitos mínimos de PC ---
  
  grok {
    match => { 
      "pc_requirements_min" => [
        # Intenta capturar un patrón más completo, que es común
        "SO: .*?%{DATA:min_os}\. Procesador: %{DATA:min_cpu}\. Memoria: .*?%{NUMBER:min_ram_gb:int} GB de RAM Gráficos: .*?%{DATA:min_gpu} DirectX: .*?%{DATA:min_directx}.*",
        # Patrón para los que no tienen el SO
        "Procesador: .*?%{DATA:min_cpu} Memoria: .*?%{NUMBER:min_ram_gb:int} GB de RAM Gráficos: .*?%{DATA:min_gpu} DirectX: .*?%{DATA:min_directx}.*"
      ]
    }
    tag_on_failure => [ "grok_pc_fail" ]
    remove_field => ["pc_requirements_min"] 
  }

  mutate {
    # Convertir campos numéricos y booleanos.
    convert => {
      "price_eur"          => "float"
      "price_initial_eur"  => "float"
      "discount_pct"       => "integer"
      "metacritic_score"   => "integer"
      "recommendations_total" => "integer"
      "achievements_count" => "integer"
      "is_free"            => "boolean"
      "steam_id"           => "integer"
      "min_ram_gb"         => "integer"
      "vector_embedding" => "float" 
    }
    

    rename => {
      "steam_id"  => "appid"
      "price_eur" => "price_final"
    }
    
    # Limpieza final de campos no necesarios 
    remove_field => [
      "message",
      "@version",
      "host",
      "path",
      "type",
      "tags", 
      "event",
      "message" 
    ]
  }

  ruby {
    code => '
      price = event.get("price_final")
      is_free = event.get("is_free")

      if is_free == true || (price && price == 0)
        event.set("price_category", "Gratis")
      elsif price && price < 15.0
        event.set("price_category", "Barato")
      elsif price && price < 40.0
        event.set("price_category", "Normal")
      else
        event.set("price_category", "Premium")
      end
    '
  }

  mutate {
    add_field => { "last_updated" => "%{@timestamp}" }
  }
  
  date {
    match => ["last_updated", "ISO8601"]
    target => "last_updated"
  }
}

output {
  elasticsearch {
    index => "steam_games-%{+yyyy.MM.dd}" 
    hosts => ["https://192.199.1.53:9200", "https://192.199.1.65:9200", "https://192.199.1.66:9200"]
    api_key => "hqQJypoBqiFKKsx-mbaD:mZRPaYKSOrm7CpnWEDJ2xg"
    
    # Configuración SSL/TLS
    ssl_certificate_authorities => ["/home/g6/reto/elasticsearch-9.2.1/config/certs/http_ca.crt"]
    ssl_verification_mode => "full"
    
    document_id => "%{appid}"
    resurrect_delay => 60
    sniffing => false
  }
  
  # stdout {
  #   codec => rubydebug
  # }
}